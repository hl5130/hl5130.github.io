<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android NDK 开发入门（一）]]></title>
    <url>%2F2019%2F04%2F10%2FAndroid-NDK-%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介NDK开发适用于音频、视频、3D图形、相机驱动等开发。 开发工具简介 Android NDK：是AndroidStudio的原生开发工具包，允许使用C和C++代码 CMake：一款外部构建工具，可与Gradle搭配使用来构建原生库。如果只使用ndk-build，就不需要此组件 LLDB：用来调试原生代码开发工具下载 打开 SDK Manager 点击 SDK Tools 标签 选中 LLDB、CMake 和 NDK 点击 Apply，然后在弹出式对话框中点击 OK 安装完成，点击 Finish，然后点击 OK 创建支持 C/C++ 的新项目开发环境 Mac 系统 Android Studio 3.3.2 Gradle 版本：gradle-4.10.1-all 搭建步骤因为使用的是 Android Studio 3.3.2，在创建新项目的时候没有 Include C++ Support 这个选项了，所以现在先创建基础项目，再关联C/C++ 创建基础项目 创建新的原生源文件，并添加到项目中 创建 CMake 构建脚本，将原生源代码构建到库中 Gradl 与原生库关联 创建新的原生源文件在应用模块的主源代码集中创建一个包含新建原生源文件的cpp/目录，步骤如下： 选择 Project 视图 导航到 自己模块 &gt; src &gt; main ,在 main 目录中创建一个新的文件夹cpp 在cpp目录中创建C/C++文件；创建此文件时可以选择创建标头文件 创建 CMake 构建脚本CMake 构建脚本是一个纯文本文件，您必须将其命名为 CMakeLists.txt。这里只介绍了基本命令 选择 Project 视图 在自己模块的根目录下创建文件，命名CMakeLists.txt 配置脚本 1234567891011121314151617181920# 设置 CMake 的最低版本cmake_minimum_required(VERSION 3.4.1)# Specifies a library name, specifies whether the library is STATIC or# SHARED, and provides relative paths to the source code. You can# define multiple libraries by adding multiple add.library() commands,# and CMake builds them for you. When you build your app, Gradle# automatically packages shared libraries with your APK.add_library( # Specifies the name of the library. 这个库的名字 main # Sets the library as a shared library. 这个库的类型 SHARED # Provides a relative path to your source file(s). 源文件的路径 src/main/cpp/main.cpp)# Specifies a path to native header files. 标头文件的路径include_directories(src/main/cpp/include/) 最后生成的原生库，是有命名规范的 1lib库名称.so Gradle 与原生库关联要将 Gradle 关联到您的原生库，您需要提供一个指向 CMake 或 ndk-build 脚本文件的路径。在您构建应用时，Gradle 会以依赖项的形式运行 CMake 或 ndk-build，并将共享的库打包到您的 APK 中。Gradle 还使用构建脚本来了解要将哪些文件添加到您的 Android Studio 项目中，以便您可以从 Project 窗口访问这些文件。如果您的原生源文件没有构建脚本，则需要先创建 CMake 构建脚本，然后再继续。 将 Gradle 关联到原生项目后，Android Studio 会更新 Project 窗格以在 cpp 组中显示您的源文件和原生库，在 External Build Files 组中显示您的外部构建脚本。 注：更改 Gradle 配置时，请确保通过点击工具栏中的 Sync Project 应用更改。此外，如果在将 CMake 或 ndk-build 脚本文件关联到 Gradle 后再对其进行更改，您应当从菜单栏中选择 Build &gt; Refresh Linked C++ Projects，将 Android Studio 与您的更改同步。 关联步骤： 从 IDE 左侧打开 Project 窗格并选择 Android 视图 右键点击您想要关联到原生库的模块（例如 app 模块），并从菜单中选择 Link C++ Project with Gradle 选择 CMake，请使用 Project Path 旁的字段为您的外部 CMake 项目指定 CMakeLists.txt 脚本文件 点击OK就可以了 检测是否成功所有工作完成之后，打包APK，对APK进行分析，发现在lib目录下有CPU架构文件夹，每一个文件夹中都有libmain.so文件，就说明成功了。步骤如下： Build &gt; Build Bundle(s)/ APK(S) &gt; Buidl APK(S) 等待打包完成，点开Anaylze APK 出现的窗体中，打开lib目录，打开其中一个CPU架构目录(例如x86)，就会看见libmain.so 利用 JNI 调用原生库JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++） 使用方法以上面的原生库为例子，介绍 JNI 源文件 main.cpp12345678910#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot; JNIEXPORT jstringJNICALLJava_com_hongliang_ndkdemo_NDKMainHelper_getNDKPrint(JNIEnv *env, jobject /* this */) &#123; std::string hello = &quot;NDKDemo&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; #include &lt;jni.h&gt; 声明此文件要使用 jni 的内容 #include &lt;string&gt; 因为需要使用到 String，所以要声明 Java_com_hongliang_ndkdemo_NDKMainHelper_hello 这个是最重要的，因为是有命名规范的：Java_包名_类名_方法名。可以理解为调用com.hongliang.ndkdemo包下NDKMainHelper类的hello方法，实际是调用 main.cpp 的 Java_com_hongliang_ndkdemo_NDKMainHelper_hello 函数 Java 文件 NDKMainHelper123456789package com.hongliang.ndkdemo;public class NDKMainHelper &#123; static &#123; System.loadLibrary(&quot;main&quot;); &#125; public native String getNDKPrint();&#125; static 静态块中加载原生库 System.loadLibrary(&quot;main&quot;)，使用的是库名 native 标志此方法是调用原生库的函数 Activity文件123456789101112131415161718package com.hongliang.ndkdemo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); NDKMainHelper ndkMainHelper = new NDKMainHelper(); String msg = ndkMainHelper.getNDKPrint(); Log.e(&quot;MainActivity&quot;, msg); &#125;&#125; 在 MainActivity 中创建 NDKMainHelper 的对象，并调用 getNDKPrint 方法，此时就会调用 main.cpp 的函数了。 最终打印出来的是：NDKDemo 文献官方文档]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttpClient的Timeout解析]]></title>
    <url>%2F2019%2F04%2F08%2FOkHttpClient%E7%9A%84Timeout%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简介okHttp3要设置OkHttpClient的TimeOut，需要通过OkHttpClient.Builder来设置。如下代码：123456OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(15,TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS) .writeTimeout(20, TimeUnit.SECONDS) .cache(new Cache(file,10*1024*1024)) .build(); 有时候我很疑惑，connectTimeout、readTimeout、writeTimeout，到底有什么用？下面来讲解一下： 解析首先简单说一下socket，因为okHttp是基于socket实现的。 socketsocket是对网络传输层TCP/IP协议的封装，便于程序员进行使用。它定义了一些基本的函数：create、listen、connect、accept、send、read和write等等。其中connect对应于TCP协议中的三次握手建立连接，read对应于建立连接之后客户端读取服务器数据的操作，write对应于建立连接之后客户端向服务器写入数据的操作。只需要了解这些就可以了，如果要深入了解，请查看《TCP/IP、Http、Socket区别》这一篇文章。 connectTimeoutconnectTimeout 既连接超时。精确来讲就是客户端和服务器要在设置的时间内进行三次握手并建立连接，如果在此时间内没有建立连接，那就是连接超时。作用：限制客户端和服务器建立连接的时间，减少服务器的压力，释放更多资源供其他连接使用。 readTimeoutreadTimeout 既读取超时。精确来讲就是客户端要在规定的时间内从服务器读取到数据内容，注意不是读取所有数据花费的时间。例如服务器有一个大小为100字节的数据，只要客户端在 readTimeout时间内能够从服务器读取到1字节的数据，就不会超时。举一个更生动的例子：用桶接水，打开水龙头(三次握手成功建立了连接)，有水流出来，无论大小(获取到的数据流大小)，但都是有水的；此时停水了(相当于出现了网络状况，导致读取不到数据了)，从现在开始计算到readTimeout时间，还没有水出来的话(说明读取超时了)，就关闭水龙头(关闭连接)。 writeTimeoutwriteTimeout 既写入超时。精确来讲就是客户端向服务器上传文件时，要在规定的时间向服务器发送数据。比如我要发10M的数据，结果只发了1M出去，网络就一直丢包，从这个时间起就开始算超时，但是只要有新的数据发出去了那么超时就重新计算。说白了超时就是每次最多干等的时间。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp3解析]]></title>
    <url>%2F2019%2F04%2F08%2Fokhttp3%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp3基本使用]]></title>
    <url>%2F2019%2F04%2F08%2Fokhttp3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介从Android4.4开始，系统内置了OkHttp。 okHttp3 有重大改版，例如 FormEncodingBuilder 类没有了，取而代之的是 FormBody。 基本步骤 创建 OkHttpClient 创建 Request 创建 Call 调用 Call 的 enqueue() 或者 execute() GET请求123456789101112131415161718192021222324252627282930// 1、RequestRequest.Builder builder = new Request.Builder();builder.url(&quot;http://www.hong1969.com&quot;);builder.method(&quot;GET&quot;,null);Request request = builder.build();// 2、 HttpClientOkHttpClient client = new OkHttpClient();// 3、CallCall call = client.newCall(request);// 4、异步请求call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; e.printStackTrace(); &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123; ResponseBody responseBody = response.body(); if (null != responseBody) &#123; String string = responseBody.string(); Log.e(LOG_TAG,&quot;返回结果：&quot;+string); &#125; else &#123; Log.e(LOG_TAG,&quot;ResponseBody is null&quot;); &#125; &#125;&#125;); POST请求123456789101112131415161718192021222324252627282930313233343536// 1、FormBodyFormBody.Builder formBodyBuilder = new FormBody.Builder();formBodyBuilder.add(&quot;username&quot;,&quot;admin&quot;);formBodyBuilder.add(&quot;password&quot;,&quot;123456&quot;);FormBody formBody = formBodyBuilder.build();// 2、RequestRequest.Builder builder = new Request.Builder();builder.url(&quot;http://distributionapi.1000fun.com/login/userlogin&quot;);builder.method(&quot;POST&quot;,formBody);Request request = builder.build();// 3、 HttpClientOkHttpClient client = new OkHttpClient();// 4、CallCall call = client.newCall(request);// 5、异步请求call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; e.printStackTrace(); &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123; ResponseBody responseBody = response.body(); if (null != responseBody) &#123; String string = responseBody.string(); Log.e(LOG_TAG,&quot;返回结果：&quot;+string); &#125; else &#123; Log.e(LOG_TAG,&quot;ResponseBody is null&quot;); &#125; &#125;&#125;); 异步上传文件 上传文件也是POST请求，并使用RequestBody设置请求体 上传文件的格式通过MediaType来设置。例如MediaType mediaType = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;)就是用来设置上传txt文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1、文件路径String filePath = &quot;&quot;;if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123; filePath = Environment.getExternalStorageDirectory().getAbsolutePath();&#125; else &#123; return;&#125;// 2、文件File file = new File(filePath,&quot;wangshu.txt&quot;);// 3、RequestBody，上传的是txt格式的文件MediaType mediaType = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);RequestBody requestBody = RequestBody.create(mediaType, file);// 4、RequestRequest.Builder requestBuilder = new Request.Builder();requestBuilder.url(&quot;https://api.github.com/markdown/raw&quot;) .post(requestBody) .build();Request request = requestBuilder.build();// 5、HttpClientOkHttpClient client = new OkHttpClient();// 6、CallCall call = client.newCall(request);call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; e.printStackTrace(); if (e instanceof FileNotFoundException)&#123; Log.e(LOG_TAG,&quot;该文件不存在&quot;); &#125; &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123; ResponseBody responseBody = response.body(); if (null != responseBody) &#123; String string = responseBody.string(); Log.e(LOG_TAG,&quot;返回结果：&quot;+string); &#125; else &#123; Log.e(LOG_TAG,&quot;ResponseBody is null&quot;); &#125; &#125;&#125;); 异步下载文件 可以不用设置请求方式 通过IO流对Response进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1、RequestString url = &quot;https://www.baidu.com/img/bd_logo1.png&quot;;Request request = new Request.Builder().url(url).build();// 2、OkHttpClient 设置OkHttpClient client = new OkHttpClient();// 3、CallCall call = client.newCall(request);call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; e.printStackTrace(); if (e instanceof FileNotFoundException)&#123; Log.e(LOG_TAG,&quot;该文件不存在&quot;); &#125; &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) &#123; ResponseBody responseBody = response.body(); if (null != responseBody) &#123; InputStream inputStream = responseBody.byteStream(); String filePath; try &#123; if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123; filePath = Environment.getExternalStorageDirectory().getAbsolutePath(); &#125; else &#123; filePath = context.getFilesDir().getAbsolutePath(); &#125; File file = new File(filePath,&quot;wangshu.jpg&quot;); FileOutputStream fileOutputStream = new FileOutputStream(file); byte[] buffer = new byte[1024]; int len = 0; while ( (len = inputStream.read(buffer)) != -1)&#123; fileOutputStream.write(buffer,0,len); &#125; fileOutputStream.flush(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; else &#123; Log.e(LOG_TAG,&quot;ResponseBody is null&quot;); &#125; &#125;&#125;); 异步上传Multipart文件使用场景在上传文件的时候，需要同时上传参数 基本步骤 使用MultipartBody.Builder创建RequestBody 创建Request，并包含RequestBody 其他步骤不变 123456789101112131415161718192021222324252627282930313233// 1、设置MediaTypefinal MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;);// 2、设置 RequestBodyRequestBody requestBody = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(&quot;title&quot;,&quot;wangshu&quot;) // 第一个参数是key值，第二个参数上传文件的名字，第三个参数是上传的文件 .addFormDataPart(&quot;image&quot;,&quot;wangshu.png&quot;, RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;/storage/emulated/0/wangshu.png&quot;))) .build();// 3、设置 RequestRequest request = new Request.Builder() .url(&quot;https://.....&quot;) .post(requestBody) .build();// 4、设置 OkHttpClientOkHttpClient okHttpClient = new OkHttpClient();// 5、 CallCall call = okHttpClient.newCall(request);call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123; &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp3配置]]></title>
    <url>%2F2019%2F04%2F08%2Fokhttp3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[依赖导入在 module 的 build.gradle 文件中添加下面的代码，并重新build12implementation &apos;com.squareup.okhttp3:okhttp:3.14.0&apos;implementation &apos;com.squareup.okio:okio:2.2.2&apos; Build 时出现的问题如果 build 失败，并出现了下面的问题：1234Caused by: com.android.builder.dexing.DexArchiveBuilderException: Failed to process /Users/hongliang/.gradle/caches/modules-2/files-2.1/com.squareup.okhttp3/okhttp/3.14.0/c3a9efd10f26a802da2c47dbe54a8d4c44a6019f/okhttp-3.14.0.jarCaused by: com.android.builder.dexing.DexArchiveBuilderException: Error while dexing.Caused by: com.android.tools.r8.CompilationFailedException: Compilation failed to completeCaused by: com.android.tools.r8.utils.AbortException: Error: Static interface methods are only supported starting with Android N (--min-api 24): okhttp3.Request okhttp3.Authenticator.lambda$static$0(okhttp3.Route, okhttp3.Response) 原因Java8之后才支持lambda和静态接口方法，所以需要指定使用Java8编译 解决办法在 module 的 build.gradle 文件中添加下面的代码，并重新build1234567android &#123; ... compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; okHttp3系列文章okHttp3-基本使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派制作复古游戏机]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%B6%E4%BD%9C%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[各位90后的小伙子们，是否还记得“魂斗罗”、“超级玛丽亚”、“双截龙”等一系列的游戏呐。这篇文章教你制作一个复古游戏机，可以运行 nes、neogeo等20几种游戏模拟器，让你满足儿时的游戏梦想。 前期准备制作复古游戏机的核心是：树莓派、MicroSD卡、系统镜像、游戏手柄；下面会依次做介绍。 树莓派树莓派是一块开发板，可以理解为微型计算机。笔者使用的树莓派3b+型号，它接口丰富——4个USB接口、一个HDMI、一个千兆网口，还配有蓝牙、WIFI等。关于树莓派的详细介绍，请点击树莓派官网查看。 MicroSD卡因为树莓派是没有存储内存的，所以需要使用 MicroSD卡作为存储内存，用来烧录镜像和放置游戏ROM，并且内存至少16GB起步，这样才能愉快地放非常非常多的游戏。笔者使用的是闪迪Class10。 镜像可以烧录在树莓派上的游戏镜像有很多，笔者推荐的是recalbox。 Recalbox 官方网站：https://www.recalbox.com 镜像下载地址：https://archive.recalbox.com，选择 “Raspberry Pi 3 / 3 B+” 就可以了 镜像下载有点慢，因此笔者在百度云盘分享了出来，取货码【e6mh】，快速到达 制作工具Mac电脑下的镜像制作在Mac电脑下，使用 balenaEtcher 做镜像烧录操作。下载地址：https://www.balena.io/etcher/ 选择 “Etcher for macOS” 就可以了 第一步使用 Mac 的磁盘工具对 MicroSD卡 进行格式化，选择“MS-DOS (FAT32)”格式。 格式化成功之后，打开 balenaEtcher 软件，点击“select image”按钮选择我们下载的 recalbox 镜像，再选择我们的 MicroSD卡，最后点击“Flash”就可以了，此时镜像开始烧录。 镜像烧录完成，将 MicroSD卡插入树莓派就可以运行了。 Windows电脑下的镜像制作再下载 balenaEtcher 时，选择“ Etcher for Windows x64 (64-bit) (Installer) ” 就可以了。除了格式化的工具不一样以外，其他步骤都一样。 游戏ROM的放入一个要求：需要树莓派和电脑在同一网段的局域网中。 在没有修改游戏系统的名字的前提下，电脑中会有一个 RECALBOX 的共享文件。 根据步骤进入各个模拟器rom文件夹：share -&gt; roms；roms文件夹中包含了所有模拟器的rom文件夹，将游戏放入对应的rom文件夹中就可以了。 重启系统，就可以看到你喜爱的游戏了。 装备玩游戏怎么能没有手柄呐，推荐两个手柄： PS3游戏手柄，蓝牙匹配，完美运行，索尼大法就是好！ 北通USB游戏手柄！ 显示器：en～ 用过28寸4K的，完美运行。不知道放到电视上会有多大的马赛克，😂]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
</search>
