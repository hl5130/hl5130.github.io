<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第二章：程序结构]]></title>
    <url>%2F2020%2F04%2F26%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[常量与变量常量val在Kotlin中常量使用val表示，一旦声明并赋值之后，在后续的程序中无法更改。注意一下几点： 运行时常量的写法 1val aa: String = &quot;HelloWord&quot; // 常量 编译器常量的写法，多增加一个const关键字，并且运行速度快于运行时常量 123const val aa: String = &quot;HelloWord&quot;// 与Java等价的代码是public final String aa = &quot;HelloWord&quot; 查看字节码，就能发现两种写法的编译生成的字节码有所不同 123456// 第一种const val aa: String = &quot;HelloWord&quot;var bb = aa// 第二种val aa: String = &quot;HelloWord&quot;var bb = aa 变量var在后续程序中可以更改的变量，用var表示12345var aa: String = &quot;123&quot;aa = &quot;234&quot; // 正确val bb: String = &quot;123&quot;bb = &quot;234&quot; // 错误，常量无法改变值 类型推导在Kotlin中，编译器可以根据变量或者常量的值，推导出它的类型123val aa = &quot;Helloween&quot; // String类型var ins = 123 // Int类型var result = &quot;Hellow&quot;+5 // String类型 函数 function以特定功能组织起来的代码块，与String、Int等一样都是一种类型，它的写法：12fun [函数名]([参数列表]):[返回值类型]&#123;[函数体]&#125;]fun [函数名]([参数列表])=[表达式] 列如：123456// 传入两个整型参数，得到他们的和fun reslut(a1:Int, b1: Int): Int &#123; print(&quot;$&#123;a1+b1&#125;&quot;) return a1+b1&#125;fun reslut(a1:Int, b1: Int) = a1+b1 函数的作用对参数进行一些变化并得到返回值，当函数体内部没有返回值时，使用Unit，它没有任何意义，并且可以省略不写1234567fun aa(): Unit&#123; print(&quot;Hellow&quot;)&#125;fun aa() &#123; // 省略了Unit print(&quot;Hellow&quot;)&#125; 匿名函数 无名氏的函数，如神一般的存在，lambad表达式更能体现出来 fun ([参数列表])...，没有函数名称，但需要有变量接收，比如1val sayHi = fun(name: String) = [print(name)]]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2020%2F04%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一章：类型]]></title>
    <url>%2F2020%2F04%2F23%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本类型布尔类型Kotlin 中的布尔类型是 Boolean，与Java的boolean性质是一样的，只有True与False两个值。12val a: Boolean = falseval b: Boolean = true Number类型Kotlin 中的Number类型，实际就是Java中的数值类型，即整型、浮点型、字节 类型分类 类型 大小(位) 浮点型-双精度 Double 64 浮点型-单精度 Float 32 长整型 Long 64 整型 Int 32 短整型 Short 16 字节 Byte 8 12345678val a: Double = 2.0val a1 = 2.0 // 默认是Double类型val b: Float = 2.0val b1 = 2.0F // 用F结尾表示Float类型val c: Long = 123val c1 = 123L // 用L结尾表示Long类型val d: Int = 123val d1 = 123 // 默认是Int类型 Char类型字符类型，占两个字节，表示一个16位的Unicode字符，使用单引号表示123val aChar: Char = &apos;a&apos;val aChar1 = &apos;a&apos;val bChar: Char = &apos;\u000f&apos; // \u000f表示Unicode码 转义字符 转义字符 含义 \t 制表符 \b 光标后退一个字符 \n 回车 \r 光标回到行首 \‘ 单引号 \“ 双引号（用于字符串） \\ 反斜杠 \$ 美元符号，Kotli支持美元符号开头的字符串模板（用于字符串） 装箱与拆箱在Java中有基本类型和装箱类型，例如int和Integer。但是在Kotlin中没有这样的说法，因为Kotlin的类型就是Java基本类型和装箱类型的合体，例如Int,Double等，到底是基本类型还是装箱类型是由编译器根据情况来选择的。 基本类型转换在Java中，可以将小的基本类型隐式转换成大的基本类型，例如：123int intA = 123long longB = intA // 正确，小转大short shortC = intA // 不正确，大转小 但是，在Kotlin中是不能隐式转换的，只能通过显示转换 类型 使用方法 Double toDouble() Float toFloat() Long toLong() Int toInt() Short toShort() Byte toByte() Char toChar() 例子:12val aInt: Int = 5val bLong: Long = aInt.toLong() 引用类型字符串String可以理解一串字符，用双引号表示1val aString: String = &quot;HelloWorld&quot; 比较符在kotlin中==相当于Java的equals()方法，即值比较；而===相当于Java的==，即对象的引用比较1234val aString: String = &quot;a&quot;val bString: String = &quot;a&quot;if( aString == bString) // Trueif( aString === bString) // False 字符串模板使用$标识变量，可以在字符串中直接输入值使用${}标识变量的表达式123456val test: String = &quot;HelloWorld&quot;print(&quot;This is $test&quot;) // 输出是：This is HelloWorldval a: Int = 1val b: Int = 2print(&quot;$a + $b = $&#123;a+b&#125;&quot;) // 输出是：1+2=3 原始字符串原始字符串的意思就是，你输入的是什么格式，输出就是什么格式，使用&quot;&quot;&quot;表示1234567val sss: String = &quot;&quot;&quot;我是测试 原始温恩&quot;&quot;&quot;// 输出的是：我是测试 原始温恩 类与对象使用class关键字的是类。只要记住类是一个抽象的概念，对象是这个类的具体实例。1class Person constructor(var name: String) &#123;&#125; 可以省略constructor关键字1class Person(var name: String) &#123;&#125; 如果类中没有任何内容，也可以省略{}1class Person(var name: String) init{}方法是构造方法体12345678class Person(var name: String) &#123; init&#123; print(&quot;我是$name&quot;) &#125;&#125;val me: Person = Person(&quot;帅哥&quot;)// 此时会输出：我是帅哥 me就是对象，一个具体的实例Person就是类，一个抽象的概念 区间（Range）区间，就是数学中的开闭区间；如整型区间IntRange。闭区间10 .. 1024 // [0,1024] 开区间10 until 1024 // [0,1024） 某个数在区间中是否存在12intRange.contairs(50) // 判断50是否在区间中存在50 in intRange // 也是判断50是否在区间中存在 数组（Array）数组是一系列的对象，包含了基本数据类型和引用数据类型123456// 基本数据类型 xxArray ,例如：整型数组val intArray: IntArray = intArrayOf(1,2,3,4)// 引用类型数组val stringArray: Array&lt;String&gt; = arrayOf(&quot;我是&quot;,&quot;睡觉了&quot;)val personArray: Array&lt;Person&gt; = arrayOf(Person(“人1”),arrayOf(Person(“人2”),arrayOf(Person(“人3”)) 注意几个问题 声明数组的时候，必须添加元素，否则会出异常12val intArray: IntArray = intArrayOf() // 此时数组中没有元素intArray[0] = 1 // 会抛出下标越界，因为 intArray 在声明时没有添加任何元素，所以它的大小是0，并且无法改变。 空类型与智能类型转换空类型在Java中，一个变量可以是空，也可以是非空，这就导致我们在使用的时候需要进行非空判断，否则容易出现空指针异常。而在Kotlin中，是分了空与非空的，用?标识1234// 可以为空var nullable: String? = null// 不可以为空var notNull: String = &quot;Not&quot; 在使用的时候也是有区别的1234nullable.length // 错误，可以为空的变量不可以直接使用notNull.length // 正确，不为空的变量可以直接使用nullable?.length // 正确，如果变量是空的就得到null，否则就是变量的大小nullable!!.length // 正确，意思就是我知道这个变量一定不为空，所以可以直接使用 空类型是Kotlin的一大特色，可以有效地避免空指针异常 智能类型转换意思是编译器会自动根据前置条件判断变量的类型1234val nullable: String? = &quot;sss&quot;if(nullable != null)&#123; nullable.length // 正确，因为在if条件中已经知道 nullable 不为空了，所以可以直接使用&#125; 包（package） 就是命名空间 在类中使用其他类，实际使用的是全路径名 com.exmple.data.Order 包的声明必须在非注释代码的第一行 import关键字，用于导入包名，减少在代码中的输入量]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android NDK 开发入门（一）]]></title>
    <url>%2F2019%2F04%2F10%2FAndroid-NDK-%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介NDK开发适用于音频、视频、3D图形、相机驱动等开发。 开发工具简介 Android NDK：是AndroidStudio的原生开发工具包，允许使用C和C++代码 CMake：一款外部构建工具，可与Gradle搭配使用来构建原生库。如果只使用ndk-build，就不需要此组件 LLDB：用来调试原生代码开发工具下载 打开 SDK Manager 点击 SDK Tools 标签 选中 LLDB、CMake 和 NDK 点击 Apply，然后在弹出式对话框中点击 OK 安装完成，点击 Finish，然后点击 OK 创建支持 C/C++ 的新项目开发环境 Mac 系统 Android Studio 3.3.2 Gradle 版本：gradle-4.10.1-all 搭建步骤因为使用的是 Android Studio 3.3.2，在创建新项目的时候没有 Include C++ Support 这个选项了，所以现在先创建基础项目，再关联C/C++ 创建基础项目 创建新的原生源文件，并添加到项目中 创建 CMake 构建脚本，将原生源代码构建到库中 Gradl 与原生库关联 创建新的原生源文件在应用模块的主源代码集中创建一个包含新建原生源文件的cpp/目录，步骤如下： 选择 Project 视图 导航到 自己模块 &gt; src &gt; main ,在 main 目录中创建一个新的文件夹cpp 在cpp目录中创建C/C++文件；创建此文件时可以选择创建标头文件 创建 CMake 构建脚本CMake 构建脚本是一个纯文本文件，您必须将其命名为 CMakeLists.txt。这里只介绍了基本命令 选择 Project 视图 在自己模块的根目录下创建文件，命名CMakeLists.txt 配置脚本 1234567891011121314151617181920# 设置 CMake 的最低版本cmake_minimum_required(VERSION 3.4.1)# Specifies a library name, specifies whether the library is STATIC or# SHARED, and provides relative paths to the source code. You can# define multiple libraries by adding multiple add.library() commands,# and CMake builds them for you. When you build your app, Gradle# automatically packages shared libraries with your APK.add_library( # Specifies the name of the library. 这个库的名字 main # Sets the library as a shared library. 这个库的类型 SHARED # Provides a relative path to your source file(s). 源文件的路径 src/main/cpp/main.cpp)# Specifies a path to native header files. 标头文件的路径include_directories(src/main/cpp/include/) 最后生成的原生库，是有命名规范的 1lib库名称.so Gradle 与原生库关联要将 Gradle 关联到您的原生库，您需要提供一个指向 CMake 或 ndk-build 脚本文件的路径。在您构建应用时，Gradle 会以依赖项的形式运行 CMake 或 ndk-build，并将共享的库打包到您的 APK 中。Gradle 还使用构建脚本来了解要将哪些文件添加到您的 Android Studio 项目中，以便您可以从 Project 窗口访问这些文件。如果您的原生源文件没有构建脚本，则需要先创建 CMake 构建脚本，然后再继续。 将 Gradle 关联到原生项目后，Android Studio 会更新 Project 窗格以在 cpp 组中显示您的源文件和原生库，在 External Build Files 组中显示您的外部构建脚本。 注：更改 Gradle 配置时，请确保通过点击工具栏中的 Sync Project 应用更改。此外，如果在将 CMake 或 ndk-build 脚本文件关联到 Gradle 后再对其进行更改，您应当从菜单栏中选择 Build &gt; Refresh Linked C++ Projects，将 Android Studio 与您的更改同步。 关联步骤： 从 IDE 左侧打开 Project 窗格并选择 Android 视图 右键点击您想要关联到原生库的模块（例如 app 模块），并从菜单中选择 Link C++ Project with Gradle 选择 CMake，请使用 Project Path 旁的字段为您的外部 CMake 项目指定 CMakeLists.txt 脚本文件 点击OK就可以了 检测是否成功所有工作完成之后，打包APK，对APK进行分析，发现在lib目录下有CPU架构文件夹，每一个文件夹中都有libmain.so文件，就说明成功了。步骤如下： Build &gt; Build Bundle(s)/ APK(S) &gt; Buidl APK(S) 等待打包完成，点开Anaylze APK 出现的窗体中，打开lib目录，打开其中一个CPU架构目录(例如x86)，就会看见libmain.so 利用 JNI 调用原生库JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++） 使用方法以上面的原生库为例子，介绍 JNI 源文件 main.cpp12345678910#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot; JNIEXPORT jstringJNICALLJava_com_hongliang_ndkdemo_NDKMainHelper_getNDKPrint(JNIEnv *env, jobject /* this */) &#123; std::string hello = &quot;NDKDemo&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; #include &lt;jni.h&gt; 声明此文件要使用 jni 的内容 #include &lt;string&gt; 因为需要使用到 String，所以要声明 Java_com_hongliang_ndkdemo_NDKMainHelper_hello 这个是最重要的，因为是有命名规范的：Java_包名_类名_方法名。可以理解为调用com.hongliang.ndkdemo包下NDKMainHelper类的hello方法，实际是调用 main.cpp 的 Java_com_hongliang_ndkdemo_NDKMainHelper_hello 函数 Java 文件 NDKMainHelper123456789package com.hongliang.ndkdemo;public class NDKMainHelper &#123; static &#123; System.loadLibrary(&quot;main&quot;); &#125; public native String getNDKPrint();&#125; static 静态块中加载原生库 System.loadLibrary(&quot;main&quot;)，使用的是库名 native 标志此方法是调用原生库的函数 Activity文件123456789101112131415161718package com.hongliang.ndkdemo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); NDKMainHelper ndkMainHelper = new NDKMainHelper(); String msg = ndkMainHelper.getNDKPrint(); Log.e(&quot;MainActivity&quot;, msg); &#125;&#125; 在 MainActivity 中创建 NDKMainHelper 的对象，并调用 getNDKPrint 方法，此时就会调用 main.cpp 的函数了。 最终打印出来的是：NDKDemo 文献官方文档]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttpClient的Timeout解析]]></title>
    <url>%2F2019%2F04%2F08%2FOkHttpClient%E7%9A%84Timeout%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简介okHttp3要设置OkHttpClient的TimeOut，需要通过OkHttpClient.Builder来设置。如下代码：123456OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(15,TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS) .writeTimeout(20, TimeUnit.SECONDS) .cache(new Cache(file,10*1024*1024)) .build(); 有时候我很疑惑，connectTimeout、readTimeout、writeTimeout，到底有什么用？下面来讲解一下： 解析首先简单说一下socket，因为okHttp是基于socket实现的。 socketsocket是对网络传输层TCP/IP协议的封装，便于程序员进行使用。它定义了一些基本的函数：create、listen、connect、accept、send、read和write等等。其中connect对应于TCP协议中的三次握手建立连接，read对应于建立连接之后客户端读取服务器数据的操作，write对应于建立连接之后客户端向服务器写入数据的操作。只需要了解这些就可以了，如果要深入了解，请查看《TCP/IP、Http、Socket区别》这一篇文章。 connectTimeoutconnectTimeout 既连接超时。精确来讲就是客户端和服务器要在设置的时间内进行三次握手并建立连接，如果在此时间内没有建立连接，那就是连接超时。作用：限制客户端和服务器建立连接的时间，减少服务器的压力，释放更多资源供其他连接使用。 readTimeoutreadTimeout 既读取超时。精确来讲就是客户端要在规定的时间内从服务器读取到数据内容，注意不是读取所有数据花费的时间。例如服务器有一个大小为100字节的数据，只要客户端在 readTimeout时间内能够从服务器读取到1字节的数据，就不会超时。举一个更生动的例子：用桶接水，打开水龙头(三次握手成功建立了连接)，有水流出来，无论大小(获取到的数据流大小)，但都是有水的；此时停水了(相当于出现了网络状况，导致读取不到数据了)，从现在开始计算到readTimeout时间，还没有水出来的话(说明读取超时了)，就关闭水龙头(关闭连接)。 writeTimeoutwriteTimeout 既写入超时。精确来讲就是客户端向服务器上传文件时，要在规定的时间向服务器发送数据。比如我要发10M的数据，结果只发了1M出去，网络就一直丢包，从这个时间起就开始算超时，但是只要有新的数据发出去了那么超时就重新计算。说白了超时就是每次最多干等的时间。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp3解析]]></title>
    <url>%2F2019%2F04%2F08%2Fokhttp3%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp3基本使用]]></title>
    <url>%2F2019%2F04%2F08%2Fokhttp3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介从Android4.4开始，系统内置了OkHttp。 okHttp3 有重大改版，例如 FormEncodingBuilder 类没有了，取而代之的是 FormBody。 基本步骤 创建 OkHttpClient 创建 Request 创建 Call 调用 Call 的 enqueue() 或者 execute() GET请求123456789101112131415161718192021222324252627282930// 1、RequestRequest.Builder builder = new Request.Builder();builder.url(&quot;http://www.hong1969.com&quot;);builder.method(&quot;GET&quot;,null);Request request = builder.build();// 2、 HttpClientOkHttpClient client = new OkHttpClient();// 3、CallCall call = client.newCall(request);// 4、异步请求call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; e.printStackTrace(); &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123; ResponseBody responseBody = response.body(); if (null != responseBody) &#123; String string = responseBody.string(); Log.e(LOG_TAG,&quot;返回结果：&quot;+string); &#125; else &#123; Log.e(LOG_TAG,&quot;ResponseBody is null&quot;); &#125; &#125;&#125;); POST请求123456789101112131415161718192021222324252627282930313233343536// 1、FormBodyFormBody.Builder formBodyBuilder = new FormBody.Builder();formBodyBuilder.add(&quot;username&quot;,&quot;admin&quot;);formBodyBuilder.add(&quot;password&quot;,&quot;123456&quot;);FormBody formBody = formBodyBuilder.build();// 2、RequestRequest.Builder builder = new Request.Builder();builder.url(&quot;http://distributionapi.1000fun.com/login/userlogin&quot;);builder.method(&quot;POST&quot;,formBody);Request request = builder.build();// 3、 HttpClientOkHttpClient client = new OkHttpClient();// 4、CallCall call = client.newCall(request);// 5、异步请求call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; e.printStackTrace(); &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123; ResponseBody responseBody = response.body(); if (null != responseBody) &#123; String string = responseBody.string(); Log.e(LOG_TAG,&quot;返回结果：&quot;+string); &#125; else &#123; Log.e(LOG_TAG,&quot;ResponseBody is null&quot;); &#125; &#125;&#125;); 异步上传文件 上传文件也是POST请求，并使用RequestBody设置请求体 上传文件的格式通过MediaType来设置。例如MediaType mediaType = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;)就是用来设置上传txt文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1、文件路径String filePath = &quot;&quot;;if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123; filePath = Environment.getExternalStorageDirectory().getAbsolutePath();&#125; else &#123; return;&#125;// 2、文件File file = new File(filePath,&quot;wangshu.txt&quot;);// 3、RequestBody，上传的是txt格式的文件MediaType mediaType = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);RequestBody requestBody = RequestBody.create(mediaType, file);// 4、RequestRequest.Builder requestBuilder = new Request.Builder();requestBuilder.url(&quot;https://api.github.com/markdown/raw&quot;) .post(requestBody) .build();Request request = requestBuilder.build();// 5、HttpClientOkHttpClient client = new OkHttpClient();// 6、CallCall call = client.newCall(request);call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; e.printStackTrace(); if (e instanceof FileNotFoundException)&#123; Log.e(LOG_TAG,&quot;该文件不存在&quot;); &#125; &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123; ResponseBody responseBody = response.body(); if (null != responseBody) &#123; String string = responseBody.string(); Log.e(LOG_TAG,&quot;返回结果：&quot;+string); &#125; else &#123; Log.e(LOG_TAG,&quot;ResponseBody is null&quot;); &#125; &#125;&#125;); 异步下载文件 可以不用设置请求方式 通过IO流对Response进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1、RequestString url = &quot;https://www.baidu.com/img/bd_logo1.png&quot;;Request request = new Request.Builder().url(url).build();// 2、OkHttpClient 设置OkHttpClient client = new OkHttpClient();// 3、CallCall call = client.newCall(request);call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; e.printStackTrace(); if (e instanceof FileNotFoundException)&#123; Log.e(LOG_TAG,&quot;该文件不存在&quot;); &#125; &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) &#123; ResponseBody responseBody = response.body(); if (null != responseBody) &#123; InputStream inputStream = responseBody.byteStream(); String filePath; try &#123; if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123; filePath = Environment.getExternalStorageDirectory().getAbsolutePath(); &#125; else &#123; filePath = context.getFilesDir().getAbsolutePath(); &#125; File file = new File(filePath,&quot;wangshu.jpg&quot;); FileOutputStream fileOutputStream = new FileOutputStream(file); byte[] buffer = new byte[1024]; int len = 0; while ( (len = inputStream.read(buffer)) != -1)&#123; fileOutputStream.write(buffer,0,len); &#125; fileOutputStream.flush(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; else &#123; Log.e(LOG_TAG,&quot;ResponseBody is null&quot;); &#125; &#125;&#125;); 异步上传Multipart文件使用场景在上传文件的时候，需要同时上传参数 基本步骤 使用MultipartBody.Builder创建RequestBody 创建Request，并包含RequestBody 其他步骤不变 123456789101112131415161718192021222324252627282930313233// 1、设置MediaTypefinal MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;);// 2、设置 RequestBodyRequestBody requestBody = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(&quot;title&quot;,&quot;wangshu&quot;) // 第一个参数是key值，第二个参数上传文件的名字，第三个参数是上传的文件 .addFormDataPart(&quot;image&quot;,&quot;wangshu.png&quot;, RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;/storage/emulated/0/wangshu.png&quot;))) .build();// 3、设置 RequestRequest request = new Request.Builder() .url(&quot;https://.....&quot;) .post(requestBody) .build();// 4、设置 OkHttpClientOkHttpClient okHttpClient = new OkHttpClient();// 5、 CallCall call = okHttpClient.newCall(request);call.enqueue(new Callback() &#123; @Override public void onFailure(@NonNull Call call, @NonNull IOException e) &#123; &#125; @Override public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123; &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp3配置]]></title>
    <url>%2F2019%2F04%2F08%2Fokhttp3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[依赖导入在 module 的 build.gradle 文件中添加下面的代码，并重新build12implementation &apos;com.squareup.okhttp3:okhttp:3.14.0&apos;implementation &apos;com.squareup.okio:okio:2.2.2&apos; Build 时出现的问题如果 build 失败，并出现了下面的问题：1234Caused by: com.android.builder.dexing.DexArchiveBuilderException: Failed to process /Users/hongliang/.gradle/caches/modules-2/files-2.1/com.squareup.okhttp3/okhttp/3.14.0/c3a9efd10f26a802da2c47dbe54a8d4c44a6019f/okhttp-3.14.0.jarCaused by: com.android.builder.dexing.DexArchiveBuilderException: Error while dexing.Caused by: com.android.tools.r8.CompilationFailedException: Compilation failed to completeCaused by: com.android.tools.r8.utils.AbortException: Error: Static interface methods are only supported starting with Android N (--min-api 24): okhttp3.Request okhttp3.Authenticator.lambda$static$0(okhttp3.Route, okhttp3.Response) 原因Java8之后才支持lambda和静态接口方法，所以需要指定使用Java8编译 解决办法在 module 的 build.gradle 文件中添加下面的代码，并重新build1234567android &#123; ... compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; okHttp3系列文章okHttp3-基本使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派制作复古游戏机]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%B6%E4%BD%9C%E5%A4%8D%E5%8F%A4%E6%B8%B8%E6%88%8F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[各位90后的小伙子们，是否还记得“魂斗罗”、“超级玛丽亚”、“双截龙”等一系列的游戏呐。这篇文章教你制作一个复古游戏机，可以运行 nes、neogeo等20几种游戏模拟器，让你满足儿时的游戏梦想。 前期准备制作复古游戏机的核心是：树莓派、MicroSD卡、系统镜像、游戏手柄；下面会依次做介绍。 树莓派树莓派是一块开发板，可以理解为微型计算机。笔者使用的树莓派3b+型号，它接口丰富——4个USB接口、一个HDMI、一个千兆网口，还配有蓝牙、WIFI等。关于树莓派的详细介绍，请点击树莓派官网查看。 MicroSD卡因为树莓派是没有存储内存的，所以需要使用 MicroSD卡作为存储内存，用来烧录镜像和放置游戏ROM，并且内存至少16GB起步，这样才能愉快地放非常非常多的游戏。笔者使用的是闪迪Class10。 镜像可以烧录在树莓派上的游戏镜像有很多，笔者推荐的是recalbox。 Recalbox 官方网站：https://www.recalbox.com 镜像下载地址：https://archive.recalbox.com，选择 “Raspberry Pi 3 / 3 B+” 就可以了 镜像下载有点慢，因此笔者在百度云盘分享了出来，取货码【e6mh】，快速到达 制作工具Mac电脑下的镜像制作在Mac电脑下，使用 balenaEtcher 做镜像烧录操作。下载地址：https://www.balena.io/etcher/ 选择 “Etcher for macOS” 就可以了 第一步使用 Mac 的磁盘工具对 MicroSD卡 进行格式化，选择“MS-DOS (FAT32)”格式。 格式化成功之后，打开 balenaEtcher 软件，点击“select image”按钮选择我们下载的 recalbox 镜像，再选择我们的 MicroSD卡，最后点击“Flash”就可以了，此时镜像开始烧录。 镜像烧录完成，将 MicroSD卡插入树莓派就可以运行了。 Windows电脑下的镜像制作再下载 balenaEtcher 时，选择“ Etcher for Windows x64 (64-bit) (Installer) ” 就可以了。除了格式化的工具不一样以外，其他步骤都一样。 游戏ROM的放入一个要求：需要树莓派和电脑在同一网段的局域网中。 在没有修改游戏系统的名字的前提下，电脑中会有一个 RECALBOX 的共享文件。 根据步骤进入各个模拟器rom文件夹：share -&gt; roms；roms文件夹中包含了所有模拟器的rom文件夹，将游戏放入对应的rom文件夹中就可以了。 重启系统，就可以看到你喜爱的游戏了。 装备玩游戏怎么能没有手柄呐，推荐两个手柄： PS3游戏手柄，蓝牙匹配，完美运行，索尼大法就是好！ 北通USB游戏手柄！ 显示器：en～ 用过28寸4K的，完美运行。不知道放到电视上会有多大的马赛克，😂]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
</search>
